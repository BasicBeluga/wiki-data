The final maprewrite has a, as we think, nice compromise between size and readeability. If we forget about the "<i>Tile *next;</i>" pointer, then this Tile struct is only <b>80</b> bits (10 bytes) packed, and <i>96</i> bits (12 bytes) unpacked. This seems a nice compromise in comparison with the 50 bits of the original map and much more freedom.
The final size would be 128bits (16 bytes) unpacked, which is a nice number for both 32bit and 64bit machines.

Some comments need to be reworked (especially sizewise), and there are some minor changes here and there, but this would be the final layout. We have taken the liberty of wasting some bits in areas where they are not important, eg. because of the union there is a ton of space left anyways, such as treest_t or fields_t (hedges struct). I will update this later on, but I gotta run now :)

==The Tile struct==
<pre>
#include <stdio.h>
#include <assert.h>
#define MAPSIZEX 1024
#define MAPSIZEY 1024

#define assert_compile(expr) void __ct_assert__(int a[1 - 2 * !(expr)]);

typedef signed char int8;
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned long uint32;

#define PACK // uncomment at will

typedef struct signal_t {
  uint8 type:3;      // type of signals/presignals, maybe advanced later on
  uint8 semaphore:1; // semaphore
  uint8 status1:2;   // status of the signal (red, green, orange, double orange?)
  uint8 status2:2;   // status of the signal (red, green, orange, double orange?)
	/* 0 unused bits */
} signal_t; /* 8 bits */

typedef struct track_t {
	uint8 track_type:4;
	uint8 ground_fences:2;// fences for tracks (full-detail)
	/* signals stuff */
	uint8 sig_present:2;	// position of signals (none, left, right, both)
	uint8 sig_type:3;			// type of signals/presignals, maybe advanced later on
	uint8 sig_semaphore:1;// semaphore or normal signal
	uint8 sig_status1:2;	// status of the signal (red, green, orange, double orange?)
	uint8 sig_status2:2;	// status of the signal (red, green, orange, double orange?)
	/* 0 unused bits */
} track_t; /* 16 bits */

typedef struct lift_t {
	uint8 pos:7;					// position of the lift
	uint8 moving:1;				// is it moving?
	uint8 dest:6;					// final positions of lift divided by 6
	/* 2 unused bits */
} lift_t; /* 16 bits */

typedef struct hedge_t {
	uint8 hedge_SW:4;			// hedge-type on SW border
	uint8 hedge_SE:4;			// hedge-type on SE border
	uint8 hedge_NE:4;			// hedge-type on NE border
	uint8 hedge_NW:4;			// hedge-type on NW border
	/* 0 unused bits */
} hedge_t; /* 16 bits */

#ifdef PACK
#pragma pack(push, 1)
#endif

typedef struct Tile {
	struct Tile *next;			// 32 or 64 bits depending on architecture
	struct height_t {				// height of a tile and all four corners
		int8 altitude_N:5;		// height of North corner of tile (ti.z)
		int8 height_S:3;			// height-offset of South from North corner (-2, -1, 0, +1, +2)
		int8 height_W:3;			// height-offset of West  from North corner (-2, -1, 0, +1, +2)
		int8 height_E:3;			// height-offset of East  from North corner (-2, -1, 0, +1, +2)
		/* 2 unused bits */
	} height; /* 32 bits */

	uint8 owner;						// owner of a tile, 255 no-owner ??
	uint8 surface_class:3;	// class of a surface  on a tile. Directs to surface_t union
	uint8 build_class:5;		// class of a building on a tile. Directs to build_t union
	union {
		/* splitting original uint8 type:5 into type and amount will need a rewrite of the tile
			processing for ground structs. Either that, or we use the original layout:
			uint8 type:5;
			uint8 counter:2; */
		struct {
			uint8 type:4;				// bare band, grass, snow, desert, rocks, etc.
			uint8 amount:2;			// amount of snow, grass
			uint8 counter:2;		// update counter
			/* 0 unused bits */
		} ground_t; /* 8 bits */

		/* underground for roads as grass, paved street, etc. Also for trams, crossings */
		struct {
			uint8 ground:3;			// uses 3 bits now, could be more in the future
			/* 5 unused bits */
		} street_t; /* 8 bits */

		struct {
			uint8 type:3;				// water/coast/canal
		/* I think part:4 was here because of ship docks, but that is moved to
			depots_t now. So it is not needed. I can however see future in another
			struct like: uint8 special:2; which would put ice onto the graphic water
			etc. for higher situated water (eg. lakes)
			uint8 part:4;				// for the canal locks */
			/* 3/5 unused bits */
		} water_t; /* 8 bits */

		struct {
		/* Tron suggested a uint8 index; that indexes into an array, which based
			on this index gets the right image needed. This would replace the, below,
			4 different packed variables and code with one and a static const array.
			road/rail-type is not needed, it is stored on the tile above */
			uint8 type:4;				// type of bridge, e.g. wooden, concrete, tubular
			uint8 dir:2;				// direction, we want to allow more than just two in the future
			uint8 section:1;		// is it a middle part, or a "endcap"? endcaps will not be needed for cliffs maybe
			uint8 ending:1;			// northern/southern end of bridge
			/* 0 unused bits */
		} bridge_t; /* 8 bits */

		struct { // Blathijs needs to detail this
			uint8 type:4;				// different types of support, also depending on year
			/* 4 unused bits */
		} support_t; /* 8 bits */
	} surface;	/* 8 bits */

	union {
		struct {
			uint16 index;				// index into industries array
			uint8 type;					// type of the industry (graphics)
			uint8 animation;		// animation states of industry (6 bits, some toyland 8 bits)
			uint8 sound:1;			// sound-effect generated
			uint8 built:1;			// under construction
			uint8 counter:3;		// counstruction counter
			uint8 stage:2;			// stage of construction
			/* 9 unused bits */
		} industry_t; /* 48 bits */

		struct {
			uint16 index;				// index of the station
			uint16 part:12;			// type of station, increase from :7 to accomodate more graphics
			uint16 track_type:4;// rail, electric rail, monorail, trams, maglev ...
			/* 16 unused bits */
		} station_t; /* 48 bits */

		struct {
			uint16 index;				// index of the checkpoint (allowing checkpoints to spawn across tiles)
			uint8 track_type:4;	// rail, electric rail, monorail, trams, maglev ...
			uint8 dir:2;				// direction
			uint8 transport_type:2;				// road/rail/bouys
			/* 24 unused bits */
		} checkpoint_t; /* 48 bits */

		struct {
			uint8 track_type:4;	// rail, electric rail, monorail, trams, maglev ...
			uint8 type:4;				// road, rail, water
			uint8 part:4;				// part of the depot (ship depots)
			uint8 dir:2;				// direction
			/* 34 unused bits */
		} depot_t; /* 48 bits */

		struct { //This might end up in the support_t stuff one day
			uint8 type:2;				// road or rail
			uint8 dir:2;				// direction
			uint8 track_type:4;	// well .. you got the point
			/* 40 unused bits */
		} tunnel_t; /* 48 bits */

		struct {
			uint8 status;				// REAL locks sometime, we need status of the doors/lift
			uint8 dir:1;				// direction of locks
			uint8 type:3;				// canal or lock or water
			uint8 part:3;				// part of the lock
			/* 33 unused bits */
		} canal_t; /* 48 bits */

		//struct {
		//	uint16 tracks;				// which tracks are present
		//	uint8 track_type:4;		// what type of track (should be 4?)
		//	uint8 ground_fences:4;// fences for tracks (full-detail)
		//	uint8 signal_configuration;
		//	struct signal_t signal_stat[2];		// signals on the tile (2x 8 bits)
		//	/* 0 unused bits */
		//} railway_t; /* 48 bits */

		struct {
			uint8 tracks;						// which tracks are present
			uint8 second_owner;
			struct track_t track_info[2]; // (2x 16 bits)
			/* 0 unused bits */
		} railway_t; /* 48 bits */

		struct roadnrail_t { // this is for diagonal roads, if we wanna have road and rail side-by-side
			// needs finalizing of course
			uint8 trackbits;			// 0 - horizontal, 1 - vertical
			uint8 roadpieces;			//
			struct signal_t signal;			// only one signal can be here (8 bits)
			uint8 road_owner;			//
			/* 16 unused bits */
		} roadnrail_t; /* 48 bits */

		struct tram_t { //void currently
			uint8 nothing;
			/* 48 unused bits */
		} tram_t; /* 48 bits */

		struct {
			uint8 pieces;					// roads which are present on a tile
			/* 40 unused bits */
		} road_t; /* 48 bits */

		struct {
			uint8 road_owner;			// owner of the road (track owner is in Tile)
			uint8 track_type:4;		// rail-types
			uint8 lights:1;				// crossing lights on/off
			uint8 dir:2;					// do we want to be more flexible in the future
			/* 33 unused bits */
		} crossing_t; /* 48 bits */

		struct {
			struct lift_t lift;		// lift (16 bits)
			uint16 index:11;			// index to which town a building belongs to
			uint16 stage:2;				// stage of construction
			uint16 counter:3;			// construction counter
			uint8 type;						// town building type
			/* 8 unused bits */
		} town_t; /* 48 bits */

		struct {
			uint8 type;						// type of trees
			uint8 counter:4;			// update counter
			uint8 count:2;				// number of trees
			/* 2 unused bits */
			struct hedge_t hedge;	// 16 bits
			uint8 growth:3;				// growth status
			/* 13 unused bits */
		} trees_t; /* 48 bits */

		struct {
			struct hedge_t hedge;	// 16 bits
			uint8 type:4;					// type of farm-fields
			uint8 counter:2;			// update counter for fields
			/* 26 unused bits */
		} fields_t;	/* 48 bits */

		struct {
			uint8 type;						// unmoveables like transmitter, lighthouse, HQ
			/* 40 unused bits */
		} unmovable_t; /* 48 bits */
	} build; /* 48 bits */
	/* 8 unused bits */
	} Tile;
#ifdef PACK
#pragma pack(pop)
	assert_compile(sizeof(Tile) == 15);
#else
	assert_compile(sizeof(Tile) == 16);
#endif

Tile _map[MAPSIZEX][MAPSIZEY];

int main ( void ) {
	printf("Tile\n");
	printf("|-- *next:          %3d\n", sizeof(_map[0][0].next)*8);
	printf("|-- height:         %3d\n", sizeof(_map[0][0].height)*8);
	printf("|-- owner:          %3d\n", sizeof(_map[0][0].owner)*8);
	printf("|-- class:            8\n");
	printf("|-- surface:        %3d\n",sizeof(_map[0][0].surface)*8);
	printf("    |-- ground:          %3d\n",sizeof(_map[0][0].surface.ground_t)*8);
	printf("    |-- water:           %3d\n",sizeof(_map[0][0].surface.water_t)*8);
	printf("    |-- bridge:          %3d\n",sizeof(_map[0][0].surface.bridge_t)*8);
	printf("    |-- support:         %3d\n",sizeof(_map[0][0].surface.support_t)*8);
	printf("|-- build:          %3d\n",sizeof(_map[0][0].build)*8);
	printf("    |-- industry         %3d\n",sizeof(_map[0][0].build.industry_t)*8);
	printf("    |-- station          %3d\n",sizeof(_map[0][0].build.station_t)*8);
	printf("    |-- checkpoint       %3d\n",sizeof(_map[0][0].build.checkpoint_t)*8);
	printf("    |-- depot            %3d\n",sizeof(_map[0][0].build.depot_t)*8);
	printf("    |-- tunnel           %3d\n",sizeof(_map[0][0].build.tunnel_t)*8);
	printf("    |-- canal:           %3d\n",sizeof(_map[0][0].build.canal_t)*8);
	printf("    |-- railway          %3d\n",sizeof(_map[0][0].build.railway_t)*8);
	printf("        |-- track          %3d\n",sizeof(_map[0][0].build.railway_t.track_info)*8);
	printf("        |-- track          %3d\n",sizeof(_map[0][0].build.railway_t.track_info)*8);
	printf("    |-- roadnrail        %3d\n",sizeof(_map[0][0].build.roadnrail_t)*8);
	printf("        |-- signal          %3d\n",sizeof(_map[0][0].build.roadnrail_t.signal)*8);
	printf("    |-- tram             %3d\n",sizeof(_map[0][0].build.tram_t)*8);
	printf("    |-- road:            %3d\n",sizeof(_map[0][0].build.road_t)*8);
	printf("    |-- crossing:        %3d\n",sizeof(_map[0][0].build.crossing_t)*8);
	printf("    |-- town:            %3d\n",sizeof(_map[0][0].build.town_t)*8);
	printf("        |-- lift            %3d\n",sizeof(_map[0][0].build.town_t.lift)*8);
	printf("    |-- trees:           %3d\n",sizeof(_map[0][0].build.trees_t)*8);
	printf("        |-- hedges          %3d\n", sizeof(_map[0][0].build.trees_t.hedge)*8);
	printf("    |-- fields:          %3d\n",sizeof(_map[0][0].build.fields_t)*8);
	printf("        |-- hedges          %3d\n", sizeof(_map[0][0].build.fields_t.hedge)*8);
	printf("    |-- unmovable:       %3d\n\n",sizeof(_map[0][0].build.unmovable_t)*8);
	printf("Tile (total size):  %3d (Mapsize %dx%d %dKB)\n",sizeof(_map[0][0])*8, MAPSIZEX, MAPSIZEY, sizeof(_map)/1024);
	printf("Compr. (50/%3d):               %2.1f%%\n", sizeof(_map[0][0])*8, 5000.0/(sizeof(_map[0][0])*8));
	printf("Compr. without *next(50/%3d):  %2.1f%%\n", (sizeof(_map[0][0])-sizeof(_map[0][0].next))*8, 5000.0/((sizeof(_map[0][0])-sizeof(_map[0][0].next))*8));
	printf("--The higher value the better the compression.\n");
	printf("Old-Tile (total):   %3.0f (Mapsize %dx%d %.0fKB)\n", 6.25*8, MAPSIZEX, MAPSIZEY, (6.25*MAPSIZEX*MAPSIZEY)/1024);
	return 0;
}

</pre>

==Considerations==
I was a bit worried about the amount of computation some of these structs, as you would first need to get the split part, then & or | that, and it would take too much CPU (in contrast to now of course). My worse fears became reality when I saw the assembly output of "<b><i>if (tile.height & 2) ...</i></b>" which resulted in:
<pre>
; 199  :  if (tile.height & 2) return 1;
	mov	al, BYTE PTR ?tile@@3UTile@@A+4
	shr	al, 4
	and	al, 15					; 0000000fH
	movzx	ecx, al
	and	ecx, 2
	je	SHORT $L876
</pre>

Thank god it was debug build, and optimized it resulted into the following, so all my doubts are gone like clouds in the sun:
<pre>
; 199  :  if (tile.height & 2) return 1;
	mov	al, BYTE PTR ?tile@@3UTile@@A+4
	add	esp, 32					; 00000020H
	test	al, 32					; 00000020H
	je	SHORT $L876
</pre>