[[Translation:en/Archive/Source/Network Protocol]]
Here below is a draft by me (TrueLight), how the network is going to be done.

It defines the protocol in great detail. What packages are sent when and by whom. Via this page we will remake network.c, and hopefully make it more stable and endian-compatible.

OpenTTD uses TCP as the transport for the network protocol. The networking could be done with UDP, but since OpenTTD depends on all packets arriving correctly and in order, any layer that could be made on top of UDP wouldn't present any significant benifits over TCP.





== Some structs ==


Below are two structs used for network info. Comments are very welcome!

<pre>
// How many clients can we have? Like.. MAX_PLAYERS - 1 is the amount of
//  players that can really play.. so.. a max of 4 spectators.. gives us..
//  MAX_PLAYERS + 3
#define MAX_CLIENTS (MAX_PLAYERS + 3)

// This is the struct used by both client and server
//  some fields will be empty on the client (like game_password) by default
//  and only filled with data a player enters.
typedef struct NetworkGameInfo {
	char server_name[40];		// Server name
	uint16 server_revision;		// The SVN version number the server is using (e.g.: '304')
								//  It even shows a SVN version in release-version, so
								//  it is easy to compare if a server is of the correct version
	byte server_lang;			// Language of the server (we should make a nice table for this)
	byte clients_max;			// Max clients allowed on server
	byte clients_on;			// Current count of clients on server
	byte specators_on;			// How many spectators do we have?
	uint16 game_date;			// Current date
	char map_name[40];			// Map which is played ["random" for a randomized map]
	uint16 map_width;			// Map width
	uint16 map_height;			// Map height
	byte map_set;				// Graphical set
} NetworkGameInfo;

typedef struct NetworkPlayerInfo {
	uint64 player_money;		// How much money the client has
	char company_name[32];		// Name of the company
	uint64 company_value;		// The current value of the company
	char password[20];			// The password for the player
} NetworkPlayerInfo;

typedef struct NetworkClientInfo {
	char client_name[40];		// Name of the client
	byte client_lang;			// The language of the client
	byte client_playas;			// As which player is this client playing
	char client_ip[15];			// IP-address of the client (so he can be banned)
	uint16 join_date;			// Gamedate the player has joined
} NetworkClientInfo;

NetworkGameInfo _network_game_info;
NetworkPlayerInfo _network_player_info[MAX_PLAYERS];
NetworkClientInfo _network_client_info[MAX_CLIENTS];

char _network_game_password[20]; // The gamepassword
</pre>

== Protocol ==


The idea: a clients logs in, verify hisself, and when it sends out a PACKET_MAP_OK, the server assumes that the client is ready and announce the user to the other players. Then the game starts. First, the joined client receives the missing frames/seed/commands between the map-frame and the current frame, so it get's in sync.
After that, all clients receive every frame (1 frame = 27ms in normal speed) a NO-OP packet when there was no command or a SERVER_COMMAND when there was a command on that frame. A client is not allowed to proceed behond the frame given in the package. When a client is done with the frame, it sends an ACK. When a server does not receive an ACK for like 5 frames, it slows down and waits for the clients.



* Client1 = one client
* ClientX = all clients connected
* Server = server

{| border="1"
|+ Network Protocol
|-
! Packet name !! From whom !! To whom !! Params !! Information
|-
|PACKET_CLIENT_GAME_INFO || Client1 || Server || <none> || Requests info about the server (current game/players/password protected)
|-
|PACKET_SERVER_GAME_INFO || Server || Client1 || GameInfo || Sends the info of the server
|-
|PACKET_CLIENT_JOIN || Client1 || Server || UserName / GamePassword || Request to join the server (with a username and a gamepassword if needed)
|-
|PACKET_SERVER_ERROR || Server || Client1 || ErrorCode || ErrorCode (login denied, kicked, stuff like that)
|-
|PACKET_SERVER_WELCOME || Server || Client1 || Other player info || Info about other players, MOTD
|-
|PACKET_CLIENT_GETMAP || Client1 || Server || <none> || The client wants the map of the server
|-
|PACKET_SERVER_MAP || Server || Client1 || Savegame || The savegame of the current map (multiple packages)
|-
|PACKET_CLIENT_MAP_OK || Client1 || Server || <none> || The client received the map correctly and is ready to join
|-
|PACKET_SERVER_JOIN || Server || ClientX || Playername || Player joins the game
|-
|PACKET_SERVER_NO_OP || Server || ClientX || RandomSeed1, frame || There was no command on this frame, RandomSeed to verify the sync of the game
|-
|PACKET_CLIENT_COMMAND || Client1 || Server || Command, p1, p2 || The clients sends a DoCommand to the server
|-
|PACKET_SERVER_COMMAND || Server || ClientX || Command, p1, p2, player, RandomSeed1, frame || There was a command on a frame, the server says which frame and how the RandomSeed was before the StateGameLoop.
|-
|PACKET_CLIENT_ACK || Client1 || Server || frame || The client is done executing this frame and is in sync
|-
|PACKET_CLIENT_CHAT || Client1 || Server || String, Type, Player || Chat message (type: 0=broadcast, 1=team, 2=client) -- A team is all clients connected to 1 game-player.
|-
|PACKET_SERVER_CHAT || Server || ClientX || FromPlayer, Type, string || Chat message
|-
|PACKET_CLIENT_QUIT || Client1 || Server || Reason || The client wants to quit the server
|-
|PACKET_CLIENT_ERROR || Client1 || Server || ErrorNo || The client made an error and is going to be disconnected. Inform the server about it (OpenTTD crash / DeSync)
|-
|PACKET_SERVER_QUIT || Server || ClientX || Player, reason || A player left the game (also sent to the quiting player)
|-
|PACKET_SERVER_SHUTDOWN || Server || ClientX || Reason || The server shuts down with a given reason, all clients are disconnected shortly after this
|-
|PACKET_SERVER_NEWGAME || Server || ClientX || <none> || The server loaded a new game (or loaded an old game, it is just the same). The clients need to send a PACKET_CLIENT_GETMAP after this to receive the new map and rejoin
|}




== Thinks to remember ==

Below is a list of things we have to remember while implenting the new network code

* check if a commands sends by user X is really from connection X (potential cheat)
* zero out any memory after string terminators before sending C strings on the network. this avoids data of a potentially comprimising nature to leak out on the Internet.
* make sure to clean up a socket when sending/receiving fails (currently the code just keeps on going with a failed client!)