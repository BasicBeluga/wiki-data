[[Translation:en/Archive/Source/Network Protocol]]
Here below is described how the network-protocol works. 

The protocol has been designed to be stable, little to no desyncs, and still fast and playable with a dialup modem. We believe we succeeded in this.

OpenTTD mostly uses TCP. It also makes use of UDP, but below you can read more about that.

== OpenTTD - TCP ==

All main communication goes via TCP. Why not UDP, you can ask. Very simple: TCP is a packet-protocol. One packet depends on the other. We are completely sure in TCP that a client or server receives a certain packet. With UDP we are not. Of course you can build a layer on top of the UDP that does this, but then you just remade TCP.

So why do we need a packet-protocol. Let me try to explain:

== Packet-protocol ==

Everything you build in OpenTTD, or change, is handled internally via a so called DoCommand. Instead of sending diffs of the memory every 10 ms or something to make clients and servers sync, we make use of this DoCommand. At the moment a client does a DoCommand, it does not execute it yet, but the command is send to the server. The server picks a frame-of-execute for the DoCommand, and sends that information to all clients. When the clients hit that frame, it executes the DoCommand. This way all clients and server keeps in sync. But as you can understand, it is needed that all packets are received, in order, by both server and clients. That is why we make use of a Packet-protocol.

== How does it work? ==

As you have read above, we send DoCommands. No in normal conditions, the server sends out a FRAME-packet every frame. In this frame it says to what frame the client can 'walk'. Just before that, the server has send all DoCommands for the max-frame in the FRAME-packet. This way, all clients 'walk' to the max-frame, and then execute all DoCommands. Because a client can never be behond the max-frame, neither can the server, all DoCommands are executed on the same frame. This is very much needed, else we get massive desyncs. Sometimes it is needed to increase the freq. of this FRAME-packet (e.g. many slow connections). Then what happens is this: the server sends out a FRAME-packet every X seconds, with in it a max-frame of X+freq. Also, all DoCommands have the frame-of-execute set on X+freq. Again, this way we are sure all DoCommands are handled at the same moment (even the same order). What does this mean? Very simple: when you build a rail for example, it can take 'freq' frames before it shows up. So as you understand, this 'freq' can not be too high. Some statistics:

{| border="1"
|+ Network Speed per Client <warning> NEEDS UPDATING! </warning>
|-
! net_frame_freq !! Upstream !! Downstream
|-
| 1 || 1.2 kbyte/sec || 1.2 kbyte/sec
|-
| 2 || 0.8 kbyte/sec || 0.8 kbyte/sec
|}

As you can see, your connection has to be really slow to adjust the frame_freq. You can change the frame_freq in the console with: '*net_frame_freq = <number>'. Remember the * in front.

== What is this desync? ==

Desync happens when a client is out of sync with the server. How do we detect that? Pretty simple: a game can only be different of content, when or DoCommands are not handled, but even worse: when the Random is not the same. OpenTTD has a home-build Randomizer, which means that on every machine it gives the same random numbers from a certain seed. So when seed = 1, and we do a random, we get on every machine, for example, 534523 back. This is very useful. We check once in the sync_freq if the seeds on both clients and server is the same. If this is not the same, it means that or the server or one of the clients did a random too much or too little. Because we can not check whichone made an error, in this case the client is kicked out of the server and can rejoin to resync.

In the old protocol this happened a lot, mostly because of a bad network-protocol. Packets were not always send in order, and clients could walk 100 frames in front of the server and received, on random frames, DoCommands. This was in 99% of the time the cause of the desync. This is fixed now. I can't remember someone complaining about a desync in this new protocol, simply, because it is almost impossible to have a different random-seed.

By default, the seeds are checked once in the 100 frames. You can alter this with '*net_sync_freq = <number>'. Do not make this number too low, because it increases bandwidth by a lot.

== LAN-detection ==

OpenTTD has a function which can detect LAN-servers. This is done via UDP. At the moment you select LAN-mode on the server, the server also starts an UDP-listener. When a client on the same LAN presses Find Server in LAN-mode, it sends an UDP-broadcast. This is one of the best things UDP has: broadcast. The server receives it, and sends his game_info back to the client. This way the client can discover a server on the local LAN. This is the only place where UDP is used.

== Joining ==

When a client joins, it first fetches some data from the server (game-info). Then it verifies itself, gives his name and, if needed, passwords. Then it asks for a copy of the current map. We do this, because we need a start. In the map is also saved the random-seeds, and we send extra the frame of which the map is. So the server makes the copy of the map, starts sending it to the server. At that moment, the server queues all new DoCommands for this client. When the client is done receiving and tells the server that it is also done loading the map, the servers dequeues all the DoCommands, and the client is given some time to get back to the frame the server is currently on (of course time passed between starting receiving and done loading. Even more on slow connections). When the client indicates it is done with the dequeue, the client is in sync and can enjoy playing.

== TODO ==

As always, not everything is done. Some things that needs to be done:
 - Ban players
 - MOTD
 - When you speak to a client or player, you can't see you said something

== The protocol ==

Below is described which packets are send (first packets is type 0, and the type increases with every packet) to or from the server. Also is added which data is expected to be in there.

The client can get the server info without authorization. But before it gets the map, it needs authorization. After it received the map, it starts playing, and also the player is announced to the other clients.


<warning> OLD version of the protocol. Will be updated soon </warning>

* Client1 = one client
* ClientX = all clients connected
* Server = server

{| border="1"
|+ Network Protocol
|-
! Packet name !! From whom !! To whom !! Params !! Information
|-
!class="checked"| PACKET_SERVER_FULL
| Server 
|| Client1 || <none> || You get this packet when you try to connect to a server which is full
|-
!class="checked"| PACKET_CLIENT_GAME_INFO 
| Client1 
|| Server || <none> || Requests info about the server (current game/players/password protected)
|-
!class="checked"| PACKET_SERVER_GAME_INFO 
| Server || Client1 || GameInfo || Sends the info of the server
|-
!class="checked"| PACKET_SERVER_CLIENT_INFO
| Server || Client1 || ClientInfo || Sends info about 1 client to other clients
|-
!class="checked"| PACKET_CLIENT_JOIN 
| Client1 || Server || UserName / GamePassword || Request to join the server (with a username and a gamepassword if needed)
|-
!class="checked"| PACKET_SERVER_ERROR 
| Server || Client1 || ErrorCode || ErrorCode (login denied, kicked, stuff like that)
|-
!class="checked"| PACKET_SERVER_WELCOME 
| Server || Client1 || <none> || Tell the client that he is joined
|-
!class="checked"| PACKET_CLIENT_GETMAP 
| Client1 || Server || <none> || The client wants the map of the server
|-
!class="checked"| PACKET_SERVER_MAP 
| Server || Client1 || Savegame || The savegame of the current map (multiple packages)
|-
!class="checked"| PACKET_CLIENT_MAP_OK 
| Client1 || Server || <none> || The client received the map correctly and is ready to join
|-
!class="checked"| PACKET_SERVER_JOIN 
| Server || ClientX || Playername || Player joins the game
|-
!class="checked"| PACKET_SERVER_FRAME 
| Server || ClientX || frame || The server sends this command every frame. The clients may only proceed to this frame!
|-
!class="checked"| PACKET_SERVER_SYNC 
| Server || ClientX || RandomSeed1 || The server sends the random-seed-1 to check if the clients are still in sync
|-
!class="checked"| PACKET_CLIENT_ACK 
| Client1 || Server || frame || The client is done executing this frame and is in sync
|-
!class="checked" |PACKET_CLIENT_COMMAND 
| Client1 || Server || Command, p1, p2 || The clients sends a DoCommand to the server
|-
!class="checked"| PACKET_SERVER_COMMAND 
| Server || ClientX || Command, p1, p2, player, RandomSeed1, frame || There was a command on a frame, the server says which frame and how the RandomSeed was before the StateGameLoop.
|-
!class="checked"| PACKET_CLIENT_CHAT 
| Client1 || Server || String, Type, Player || Chat message (type: 0=broadcast, 1=team, 2=client) -- A team is all clients connected to 1 game-player.
|-
!class="checked"| PACKET_SERVER_CHAT 
| Server || ClientX || FromPlayer, Type, string || Chat message
|-
!class="checked"| PACKET_CLIENT_QUIT 
| Client1 || Server || Reason || The client wants to quit the server
|-
!class="checked"| PACKET_CLIENT_ERROR 
| Client1 || Server || ErrorNo || The client made an error and is going to be disconnected. Inform the server about it (OpenTTD crash / DeSync)
|-
!class="checked"| PACKET_SERVER_QUIT 
| Server || ClientX || Player, reason || A player left the game (also sent to the quiting player)
|-
!class="checked"| PACKET_SERVER_ERROR_QUIT 
| Server || ClientX || Player, ErrorNo || A player left the game (also sent to the quiting player) with an error
|-
!class="unclaimed"| PACKET_SERVER_SHUTDOWN 
| Server || ClientX || Reason || The server shuts down with a given reason, all clients are disconnected shortly after this
|-
!class="unclaimed"| PACKET_SERVER_NEWGAME 
| Server || ClientX || <none> || The server loaded a new game (or loaded an old game, it is just the same). The clients need to send a PACKET_CLIENT_GETMAP after this to receive the new map and rejoin
|}