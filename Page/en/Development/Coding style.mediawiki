[[Translation:en/Development/Coding style]]
== Coding style for OpenTTD ==
=== Functions ===
* Function names use [https://www.wikipedia.org/wiki/CamelCase CamelCase] without underscores.
* Opening curly bracket '''{''' for a function starts on the next line.
* Use Foo() instead of Foo(void).
<pre>
void ThisIsAFunction()
{
}
</pre>
=== Variables ===
* Variable names are all lowercase, and use "_" as separator.
* Global variables are preceded by an underscore. ("_") Use descriptive names because leading underscores are often used for system / compiler variables.
* private and protected members are preceded by "m_"
* Pointers and references should have their reference symbol next to the name (compatibility with current code).
* Variables that are declared below one another should have their type, name or reference operator, and assignment operator aligned by spaces.
* There are set names for many variables. Those are (but not limited to): Vehicle *u, *v, *w; Station *st; Town *t; Window *w; Engine *e.
*For multiple instances, use numbers "*t1, *t2" or postfixes "*st_from, *st_to".
*Declare variables upon first usage.
*Declare iterators in their loop.
<pre>
int     number         = 10;
Vehicle *u_first_wagon = v->next;
int     value          = v->value;

uint32 _global_variable = 3750;

protected:
    char m_private_array[10];

for (int i = 0;;);
</pre>

=== Enumerations / static consts ===
*Enumerations store integers that belong logically together (railtypes, string IDs, etc.). 
*Enumeration names also use CamelCase.
*Enumerators are all caps with "_" between the words. 
*Enums are not used to store single numbers.
*Enums have consecutive numbers OR
*Enums have consecutive powers of two. Powers of two (bits) are written in hex or with the shift operator.
*Enums may have special enumerators: "_BEGIN", "_END", and "INVALID_").  See example.
*The invalid always has 0xFF, 0xFFFF, 0xFFFFFFFF as a value.
*Other special values are consecutively less than the invalid.  
*Variables that hold enumerators should have the type of the enumeration.
<pre>
enum DiagDirection {
	DIAGDIR_BEGIN = 0,
	DIAGDIR_NE  = 0,
	DIAGDIR_SE  = 1,
	DIAGDIR_SW  = 2,
	DIAGDIR_NW  = 3,
	DIAGDIR_END,
	INVALID_DIAGDIR = 0xFF,
	BROKEN_DIAGDIR = 0xFE,
};

enum {
	DEPOT_SERVICE       = (1 << 0),
	DEPOT_MASS_SEND     = (1 << 1),
	DEPOT_DONT_CANCEL   = (1 << 2),
	DEPOT_LOCATE_HANGAR = (1 << 3),
};

DiagDirection enterdir = DIAGDIR_NE;
</pre>
Numbers that store single or uncorrelated data are static consts. Those may use the naming conventions of enums.
Example:
<pre>
static const int MAXIMUM_STATIONS = 42;
</pre>

=== Control flow ===
* Put a space before the parentheses in "if", "switch", "for", and "while" statements.
* In if/else, switch, and loop statements, following statements should be inside brackets on a different line.
* Opening curly bracket '''{''' stays on the first line.
* In if without an else statements, a single statement may follow on the same line.
<pre>
  if (a == b) {
    foo();
  } else {
    bar();
  }

  if (a == b) foo();

  switch (a) {
    case 0: dosomethingshort(); break;

    case 1:
      domore();
      b = a;
      break;

    case 2: {
      int q = 345;

      doit();
      break;
    }
  }

  for (int i = 0; i < 10; i  ) {
    foo();
    bar()
  }
</pre>

=== Classes===
* Classes names also use CamelCase. 
* Classes should have "public", "protected", and "private" sections.
* Within these section the order is: types, static const members, static members, members, constructors / destructors, static methods, methods.
* Deviations from above order are allowed when the code dictates it (e.g. a static const is needed for a typedef)
* Methods and members ought to be grouped logically.
* All those sorting rules sometimes conflict which one another. Please use common sense what increases legibility of the code in such a case.
* The method implementation should indicate if it is virtual or similar by using a comment.
<pre>
class ThisIsAClass {
public:
    typedef Titem_   *ItemPtr;
private:
    static const int m_max_size = 500;
    int              m_size;
    ItemPtr*         m_items;

public:
    explicit ThisIsAClass();
   ~ThisIsAClass();

    virtual void Method();
};

/*virtual*/ void Class::Method()
{
}
</pre>

=== Templates ===
Templates are a very powerful C   tool, but they can easily confuse beginners. Thus:
* Templates are to be documented in a very clear and verbose manner. Never assume anything in the documentation.
* the template keyword and the template layout get a separate line. typenames are either "T" or preceded by a "T", integers get a single capital letter or a descriptive name preceded by "T".
<pre>
template <typename T, typename Tsomething, int N, byte Tnumber_of_something>
int Func();
</pre>

* If you are writing one or more template class in the dedicated header file, use file.hpp for its name instead of file.h. This will let others know that it is template library (includes also implementation), not just header with declarations.

=== Other (important!) rules ===
* Put a space before and after binary operators: a   b, a == b, a