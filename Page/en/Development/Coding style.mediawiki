[[Translation:en/Development/Coding style]]
'''Why a set coding style is important'''<br>
This project is an open source project. To get open source working as intended, many people should be able to comprehend the code. This implies that there is a well documented and uniform flow of code.
That does not necessarily mean that a contributor should not write optimised yet cryptic code - one should always care about performance.  However, other developers need to understand the code which means complicated parts of code '''must''' have good documentation.

'''Why we require that EVERYTHING is documented'''<br>
What is simple to some might appear very complicated to others. Documentation helps these others. Anyone should be able to improve the code. But the main reason is, that when patch contributors want their patches added to the common codebase, the code needs to be reviewed by one or more developers. Documentation makes reviewing much easier.

== Coding style for OpenTTD ==
=== Functions ===
* Function names use [https://www.wikipedia.org/wiki/CamelCase CamelCase] without underscores.
* Opening curly bracket '''{''' for a function starts on the next line.
* Use Foo() instead of Foo(void).
<pre>
void ThisIsAFunction()
{
}
</pre>
=== Variables ===
* Variable names are all lowercase, and use "_" as separator.
* Global variables are preceded by an underscore. ("_") Use descriptive names because leading underscores are often used for system / compiler variables.
* private and protected members are preceded by "m_"
* Pointers and references should have their reference symbol next to the name (compatibility with current code).
* Variables that are declared below one another should have their type, name or reference operator, and assignment operator aligned by spaces.
* There are set names for many variables. Those are (but not limited to): Vehicle *u, *v, *w; Station *st; Town *t; Window *w; Engine *e.
*For multiple instances, use numbers "*t1, *t2" or postfixes "*st_from, *st_to".
*Declare variables upon first usage.
*Declare iterators in their loop.
<pre>
int     number         = 10;
Vehicle *u_first_wagon = v->next;
int     value          = v->value;

uint32 _global_variable = 3750;

protected:
    char m_private_array[10];

for (int i = 0;;);
</pre>
*Give the variables expedient names, this increases the readability of the code
<pre>
bool is_maglev_train = true;
if (!is_maglev_train) DoSomething();
</pre>
*Some people like to introduce copies of variables to increase readability, which can waste memory. However, in some cases, especially in code pieces which are often called, it makes sense to cache some calculated variables.
<pre>
/* Unoptimized code:
 * foo is not touched inside the loop!
 */
 for (uint8 i = 0; i < 100000; i++) {
  /* Do something */
  if (value_to_check == (foo * 4) % 5 + 6) DoSomething();
  /* Do something else */
 }

/* Better:
 * The used value of foo is calculated outside the loop.
 */
 const uint32 bar = (foo * 4) % 5 + 6;
 for (uint8 i = 0; i < 100000; i++) {
  /* Do something */
  if (value_to_check == bar) DoSomething();
  /* Do something else */
 }
</pre>

=== Enumerations / static consts ===
*Enumerations store integers that belong logically together (railtypes, string IDs, etc.). 
*Enumeration names also use CamelCase.
*Enumerators are all caps with "_" between the words. 
*Enums are not used to store single numbers.
*Enums have consecutive numbers OR
*Enums have consecutive powers of two. Powers of two (bits) are written in hex or with the shift operator.
*Enums may have special enumerators: "_BEGIN", "_END", and "INVALID_").  See example.
*The invalid always has 0xFF, 0xFFFF, 0xFFFFFFFF as a value.
*Other special values are consecutively less than the invalid.  
*Variables that hold enumerators should have the type of the enumeration.
<pre>
enum DiagDirection {
	DIAGDIR_BEGIN = 0,
	DIAGDIR_NE  = 0,
	DIAGDIR_SE  = 1,
	DIAGDIR_SW  = 2,
	DIAGDIR_NW  = 3,
	DIAGDIR_END,
	INVALID_DIAGDIR = 0xFF,
	BROKEN_DIAGDIR = 0xFE,
};

enum {
	DEPOT_SERVICE       = (1 << 0),
	DEPOT_MASS_SEND     = (1 << 1),
	DEPOT_DONT_CANCEL   = (1 << 2),
	DEPOT_LOCATE_HANGAR = (1 << 3)