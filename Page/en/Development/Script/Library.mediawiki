[[Translation:en/Development/Script/Library]]
{{en/Development/Script/Navigation}}

= Libraries =

To avoid code-duplication, and every AI creator doing the same work over and over, there is the library system. There are, of course, two sides on this: creating a library, and using a library.

== Using Existing Libraries ==

To use an existing library, you just have to load it into your AI. Doing this is very simple. They layout of the library directory (bin/ai/library/):

 category1/
   some_implementation/
 category2/
   some_other_implementation/
 sets/
   priority_queue/

Say you want to use the Priority Queue, you simply do:

 import("sets.priority_queue", "PriorityQueue", 1);

The first parameter is the category and the implementation, divided with a dot ('.'). The next parameter is the name the library you import will have, in this case PriorityQueue. It can be anything you like, as long as it doesn't exist yet. The last parameter is the version you expect the library to be.

The version check is very important. If you expect version 1, but on some users computer the library is in version 2, your AI will refuse to load. This is a good thing, as a new version means something changed with the existing functions, and your AI will most likely act up if you would use it. This early problem detection system should avoid many conflicts in the future.

Now how to use the library? Simple:

 local pq = PriorityQueue(2);
 pq.Insert(2);

Of course it depends on the library which parameters should be given to the constructor, and which functions exist.

== Creating a library ==

Creating a library is like creating an AI. You create a directory in a category in bin/ai/library, and you put in it a file called 'library.nut'. Now this is almost identical with 'info.nut', as you put in your AI directory, but instead of extending AIInfo, it extends AILibrary, and instead of calling RegisterAI, you need to call RegisterLibrary. All makes sense, not? An example:

 class PriorityQueue extends AILibrary {
        function GetAuthor()      { return "OpenTTD NoAI Developers Team"; }
        function GetName()        { return "Priority Queue"; }
        function GetDescription() { return "An implementation of a Priority Queue"; }
        function GetVersion()     { return 1; }
        function GetDate()        { return "2008-06-10"; }
        function CreateInstance() { return "PriorityQueue"; }
 }

 RegisterLibrary(PriorityQueue());

Now what you need to do is to create a file called 'main.nut'. It should contain a class you named at CreateInstance(), like in your AI. Then the same rules apply as an AI. require() works as you expect, and you can define your class how ever you like.

There are some things you can not do:

* Register 2 libraries in one library.nut
* Define more than 1 class in the main.nut (or any required file)


= User contributions of libraries =
== Data Structures ==
=== Binary Heap ===

A binary heap is a efficient data structure for applications that need to select the lowest/highest value from a collection. This is commonly used in path finding

Implementations...

[[en/AI/Library Tail Recursive Heap|Tail Recursive Binary Heap]]
*'''Contributors:''' Zutty
*'''Version:''' 1.0
*'''Built For:''' r13326
*'''Depends On:''' None
*'''Notes:''' This implementation uses tail recursion.

=== Sorted Set ===

A sorted

Implementations...

[[en/AI/Library Array Sorted Set|Array Based Sorted Set]]
*'''Author:''' Zutty
*'''Version:''' 0.1
*'''Built For:''' r13326
*'''Depends On:''' None
*'''Notes:''' This is a work in progress!

== Pathfinders ==

=== Simple pathfinder ===

Simple pathfinder which doesn't handle slopes.

*'''Author:''' Morloth
*'''Version:''' 0.1
*'''Built For:''' r13434
*'''Depends On:''' None
*'''Notes:''' See [http://devs.openttd.org/~noai/morloth/samples/simple_pathfinder/ http://devs.openttd.org/~noai/morloth/samples/simple_pathfinder/] for more info!