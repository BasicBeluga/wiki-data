{{en/Note|SCP is work in progress. Currently there has not yet been a release to tt-forums nor bananas.}}

Script Communication Protocol (SCP) a protocol for AIs and Game Scripts to communicate with each other. 


== The protocol ==
The idea is that AI and Goal scripts communicate using signs placed in a pre-defined tile in one of the map corners. For now we will refer to this as the 'communication tile'. 

An AI that want to query the Game Script something, place a sign at the communication tile. The NoGo will periodically scan the signs of all companies to see if there are any signs on the communication tile and process those. If a question from a company is found, a response sign will be created using that company ID so that the AI of that company can read it.

For more details on the protocol, see [http://dev.openttdcoop.org/projects/scriptlib-scp/repository/entry/protocol.txt protocol.txt]

== SCP Library ==
To ease the usage of this protocol, there is a AI and GS library that allows sending commands between Game Scripts and AIs and handling all the low-level stuff of encoding the data into signs and decoding the signs.

=== Command Sets ===
A command set, is a set of commands that could vaguely correspond to the commands supported by a specific GameScript. However, the idea behind command sets is that if there is one Game Script providing town goals and another providing economical goals, it should be possible to combine those two in a single Game Script without the AI needing to be changed as long as the AI support both the command set "Bobs Economy set" and "Alice Town Set".

So what Bob does is that he publishes a list of commands that his Economy GS supports and also tell AI authors what data the commands expect and what the response is (if any).

Example:

'''Command Set: Bobs Economy Set'''<br/>
{|border="1"  class="wikitable sortable"
! scope="col" | Query started by
! scope="col" | Command name
! scope="col" class="unsortable"| AI->GS parameters
! scope="col" class="unsortable"| GS->AI parameters
! scope="col" class="unsortable"| Parameter description
|-
|AI
|GetEconomy
|()
|(economy)
| economy = integer enum(0 = growth, 1 = stale, 2 = depression)
|-
|AI
|GetPresident
|()
|(name, age)
|name = a string giving the name of the president of the OpenTTD country; age = an integer giving the age of the president
|-
|AI
|ProposeNewIndustry
|(type, location)
|(grant)
|type = industry type id, location = tile index, grant = 1 if new industry was constructed and 0 if not.
|-
|GS
|NewPresident
|()
|(name, age)
|name and age as in GetPresident.
|}

This means that an AI may issue the command GetPresindent with zero parameters to the Game Script. In response it will get two data values. name and age which will appear at index 0 and 1. The name response will be a string and the age response will be an integer. The ProposeNewIndustry command takes two parameters in the query from the AI to the GS that must appear in the given order and responds with 0 or 1. 

The NewPresident command is a bit different, it is not asked by the AI. Instead the GS send a query to each AI (that has done the handshaking) when there is a new president. The AI will get name of new president as Data[0] and age as Data[1]. 

=== Extra data ===
In general it is recommended that AIs and GSs are written such that if extra data is sent at the back which is not handled, that data should just be ignored. That allows the GS to in future add new parameters/responses to the end without having to create a new command set for every small addition. All command sets and commands that the GS supports is transmitted to the AI at the handshaking process, and there is also a limit of maximum 255 commands in total. So save creating new command sets for when complete re-designs or breaking of API is required.

=== Documentation ===
In this section the public interface of the library is documented.
====Main class - SCPLib====
Note that you must create an instance of SCPLib and use that to call the member functions.


'''SCPLib::AddCommand'''(_Name, _CommandSet, self, _loopback=null)<br/>
Add a command
{|border="0" padding="4" class="wikitable"
!scope="col" |
!scope="col" |
|-
|_Name
|a string with the name of the command
|-
|_CommandSet
|a string with the name of the command set
|-
|self
|optional pointer to an instance of the class where the callback function belongs to. In most cases you'll probably pass 'this' as this parameter.
|-
|_loopback
|pointer to callback function
|-
|result
|void
|}

'''SCPLib::QueryCompany'''(_usingCommand, _usingSet, _CompanyID, ...)<br/>
Send a query to a companyID (could be an AI or anyone)
{|border="0" padding="4" class="wikitable"
!scope="col" |
!scope="col" |
|-
|_usingCommand
|string with the command to send
|-
|_usingSet
|a string with the command set where the command using_command belongs to
|-
|_CompanyID
|company ID of the company to send the command to
|}

'''SCPLib::QueryServer'''(_usingCommand, _usingSet, ...)<br/>
Send a query to the server
{|border="0" padding="4" class="wikitable"
!scope="col" |
!scope="col" |
|-
|_usingCommand
|string with the command to send
|-
|_usingSet
|a string with the command set where the command using_command belongs to
|}

'''SCPLib::TellCompany'''(_usingCommand, _usingSet, _CompanyID, ...)<br/>
Tell something a companyID (could be an AI or anyone).
No answer is needed

'''SCPLib::TellServer'''(_usingCommand, _usingSet, ...)<br/>
Send a query to the server
No answer is needed

'''SCPLib::Answer'''(message, ...)<br/>
Send an answer to a previous query, it will be sent to who has made the query to you.
{|border="0" padding="4" class="wikitable"
!scope="col" |
!scope="col" |
|-
|message
|pass the message instance that you got as parameter to your callback function
|}

'''SCPLib::CanSpeakWith'''(companyID = 16)<br/>
{|border="0" padding="4" class="wikitable"
!scope="col" |
!scope="col" |
|-
|companyID
|ID of company to speak with. Defaults to 16 (Game Script)
|-
|result
|true if we could speak with that company ID, otherwise false
|}

'''SCPLib::Check'''()<br/>
Must be include a call to this function in the main loop. This function scanns for incomming communication signs and if there is any incomming messages the registred callback functions are called.

'''SCPLib::SetAIAIProtocol'''(enable)<br/>
enable or disable AIAI protocol

'''SCPLib::GetAIAIProtocol'''()<br/>
return 1/0 if AIAI protocol is enable

'''SCPLib::SCPLogging_Error'''(enable)<br/>
{|border="0" padding="4" class="wikitable"
!scope="col" |
!scope="col" |
|-
|enable
|true to enable SCP loggin error only in console
|}

'''SCPLib::SCPLogging_Info'''(enable)<br/>
If you wish help us debugging what's going on, enabling this one should help us, your console will get more noise
This also force error logging if enable.
{|border="0" padding="4" class="wikitable"
!scope="col" |
!scope="col" |
|-
|enable
|true to enable SCP loggin info in console
|}

'''SCPLib::SCPGetCommunicationTile'''()<br/>
{|border="0" padding="4" class="wikitable"
!scope="col" |
!scope="col" |
|-
|result
|the tile that is use as the Communication Tile
|}

=== Source ===
Source code can be found here: http://dev.openttdcoop.org/projects/scriptlib-scp