[[Translation:en/Development/Script/Story book]]
{{en/Note|This page describe ongoing work that haven't been decided to go into trunk yet}}

The Story book is a collection of Story pages that a Game Script can create. It can be used both by pure tutorials but also just about any scenario or goal script which want to build a game story. The complete book can be constructed when the game starts, or the GS can add pages eg. after the completion of a task/goal.

[[File:en/Development/Script/Story-book4.png]]

== GS API ==
Pages can be company specific or global. Each company will only show the pages that are either company specific or global.

Pages are stored in a pool but will get an automatic sort value based on creation order. Thus if page B is created after page A, it will always show after A in the story book.

It is possible to remove pages, but in general pages should be seen as printed as soon as you created them. It is not possible to insert pages in between existing pages.

=== Page Elements ===
All pages display the creation date and its title at the top. All further content is added by appending page elements to a page. A page element uses the full width of the page and one or more lines. Currently there are three types of page elements: text, location and goal. Text allows displaying a section of text. Location will display a link to a location on the map which can be clicked to jump there. Goal allows referring to a goal. (It is planned that the icon next to the goal will indicate if the goal is completed or not)

Due to the amount of data to supply when creating a page + page elements it is not possible to do this using a single DoCommand. Instead users need to make one API call to create the page and then one for each element to add. When you are done, call a third API method called ''Publish'' to finalize the page. After it has been published further additions to the page are rejected. Only published pages are visible to the end user.

(Zuu: I do predict a GS Library that encapsulates this into a atomic library call to create (and publish) a page with N page elements using variable argument count)

=== Methods ===
Check if a given ID is a valid story page
 bool GSStoryPage.IsValidStoryPage(story_page_id)

Check if a given ID is a published (and valid) story page
 bool GSStoryPage.IsPublishedStoryPage(story_page_id)

Check if a given ID is a valid story page element
 bool GSStoryPage.IsValidStoryPageElement(story_page_element_id)

Create a new story page. Returns the Id of the created story page.
 StoryPageID GSStoryPage.New(company, title)

Create a new story page element and append it to a page. Returns the Id of the created story page element. Type can be one of [TEXT, LOCATION or GOAL]. For type == TEXT, ''reference'' is unused and ''text'' is used for the text. When type is LOCATION, ''reference'' is the TileIndex of a tile and ''text'' is a one-line description. When type is GOAL, ''reference'' is the GoalID and ''text'' is unused.

Further note that page elements can only be appended to unpublished pages. (in the event that a goal is removed, that page element will show up as empty space in the page)
 StoryPageID GSStoryPage.New(story_page_id, type, reference, text)

Remove a story page.
 bool GSStoryPage.Remove(story_page_id)

Publish a story page. A story page will only appear for users when it has been published. Note that only the first unpublished page (in creation order) can be published.
 bool GSStoryPage.Publish(story_page_id)

Show a story page. If a global page is given, all clients are affected. Otherwise only the clients that are connected to the company related to the page.
 bool GSStoryPage.Show(story_page_id)


=== Different ways to program the Story Book ===
# At startup of GS, create and publish all your pages (as global pages). This can be used if you just want to provide some pages of text which is equal for all companies and all pages should always be visible.
# Create and publish just one or a few pages at start (of game or company). Later when a task that have been described on the last page is completed, create and publish an additional page and then GSStoryPage.ShowPage to skip to that page. This method allows both to not reveal all pages directly but also having multiple paths to go in the story depending on whatever you want.

If an API is added to restrict showing further pages until a goal have been completed, a complete book could be created at script start. All goals could also be added at start or add new ones as previous ones have been marked as completed (to not show all goals in the goal list at start).

== Example Game Script code ==

=== Create a page ===
The following code creates the page as shown in this image below. It uses a wrapper function NewStoryPage which is given later.

[[File:en/Development/Script/Story-book4.png|the image above]]:

<pre>NewStoryPage(0, GSText(GSText.STR_TITLE1), [
		[GSStoryPage.SPET_TEXT,     0, GSText(GSText.STR_PAGE1a)],
		[GSStoryPage.SPET_LOCATION, GSTown.GetLocation(0), GSText(GSText.STR_TOWN_A)],
		[GSStoryPage.SPET_TEXT,     0, GSText(GSText.STR_PAGE1b)],
		[GSStoryPage.SPET_LOCATION, GSTown.GetLocation(1), GSText(GSText.STR_TOWN_B)],
		[GSStoryPage.SPET_LOCATION, GSTown.GetLocation(2), GSText(GSText.STR_TOWN_C)],
		[GSStoryPage.SPET_GOAL,     goal, null],
]);
</pre>

=== Wrapper function ===
The following code implements an atomic method for creating pages and adding page elements to it. Eg. it abstracts away that several API calls are required as the total amount of data will in some cases need several DoCommands / network packets to be transmitted to all clients.
<pre>/**
 * This function creates a new story page with page elements
 * and finally publishes it. If any part fails, the page
 * will be removed and the function returns false.
 *
 * Args: 
 *  company, title, [ [type, reference, text], [type, reference, text], [type, reference, text], ... ]
 *   or
 *  company, title,   type, reference, text,   type, reference, text,   type, reference, text, ...
 *
 * 1) Each element is passed as an array with three unnamed elements. All elements are packed into an array.
 * 2) Each element is passed as a sequence of three arguments.
 */
function NewStoryPage(company, title, ...)
{
	local page_id = GSStoryPage.New(company, title);
	if (!GSStoryPage.IsValidStoryPage(page_id)) {
		GSLog.Error("NewStoryPage: Failed to create page");
		return false;
	}

	// Convert args to the stacked array format
	local stacked_array = [];
	if (vargc == 1) {
		stacked_array = vargv[0];
	} else {
		for (local c = 0; c + 2 < vargc; c+= 3) {
			stacked_array.append([vargv[c], vargv[c+1], vargv[c+2]]);
		}
	}

	// Process element array
	foreach(element in stacked_array) {
		local type = element[0];
		local ref = element[1];
		local text = element[2];

		local pe = GSStoryPage.NewElement(page_id, type, ref, text);
		GSLog.Info("PE: " + pe);
		if (!GSStoryPage.IsValidStoryPageElement(pe)) {
			GSLog.Error("NewStoryPage: Failed to add element");
			GSStoryPage.Remove(page_id);
			return false;
		}
	}

	// Page done => publish it
	GSStoryPage.Publish(page_id);
	if (!GSStoryPage.IsPublishedStoryPage(page_id)) {
		GSLog.Error("NewStoryPage: Failed to publish page");
		GSStoryPage.Remove(page_id);
		return false;
	}

	return true;
}</pre>

== Future plans ==
* Maybe allow referenced goals to be blocking the GUI to progress to next page until they have all been completed.
* Allow adding one or more answers for a page. (eg. to allow creating a chapter selection page)

== Old plans ==
Earlier there was an idea to solve references to industries etc. using [[en/Development/Design Drafts/Scripts/Click on String|click-on-text]]. Currently this track is not developed and the above solution with page elements have been chosen.

=== Description of click-on-text idea ===
The idea here is to implement [[en/Development/Design Drafts/Scripts/Click on String|click-on-text]] and in OpenTTD turn {TOWN}, {INDUSTRY} etc. from GS lang file into clickable text parts. When a user click on these, the main viewport moves to the location of the town, industry, etc.