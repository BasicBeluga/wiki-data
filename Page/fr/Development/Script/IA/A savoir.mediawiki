[[Translation:en/Development/Script/Need To Know]]
{{fr/Traduction|en/Development/Script/Need To Know|40}}


{{fr/NonIA}}

==Tester une IA==

===Comment ne démarrer que mon IA?===

La manière la plus facile est de fixer le paramètre de difficulté à Aucune IA, et dans une nouvelle partie, taper dans la console:

 start_ai <le nom de votre IA>

L'IA de votre choix démarrera immédiatement.

Pour lister toutes les IA en jeu, tapez dans la console:

 list_ai

La liste des IA détectées par OpenTTD est également disponible via:

 ./openttd --help

=== Charger et redémarrer des IAs ===

Toutes les IAs sont rechargées quand une nouvelle partie est lancée. Il n'y a pas besoin de redémarrer le jeu; abandonner le niveau courant et démarrer de nouveau est habituellement la méthode la plus facile pour redémarrer l'IA depuis une carte vierge (essayez <code>newgame</code> depuis la console), ou chargez un scénario paramétré pour être le même à chaque fois. La fenêtre de débogage de l'IA permet aussi de redémarrer les IAs individuellement.

Pour charger un scénario spécifique immédiatement, utilisez:

 ./openttd -g relative/path/to/scenario.scn

=== Trace et fenêtre de débogage ===

La fenêtre de débogage de l'IA est accessible depuis l'information sur le terrain (point d'interrogation rouge) intitulé "Console de débogage de l'IA". Toutes les sorties de <code>AILog.XXX()</code> vont là, et peuvent être sélectionnées par IA. L'IA peut aussi être redémarrée ici. Lors de son redémarrage, la compagnie de cette IA est supprimée (avec toutes ses propriétés), et une nouvelle IA contrôlée par le même script (qui est rechargé depuis le disque) est démarrée. Donc, pour changer l'IA, il suffit simplement de cliquer sur le bouton Recharger pour que votre nouvelle IA fonctionne.

[[File:en/Development/Script/Ai-debug-panel.png|frame|none|Fenêtre de débogage de l'IA]]

==== Arrêt sur message de trace ====
{{fr/Disponibilité|1.1}}
Depuis la révision r19544, il a été ajouté certains contrôles supplémentaires en bas de la fenêtre de débogage pour arrêter une IA quand certains messages de trace surviennent. Pour les utiliser, vous devez taper une chaîne de caractères dans la zone de texte et, quand votre IA affiche un message de trace qui correspond à cette chaîne, l'IA sera suspendue après l'appel de AILog et, à la fin de ce tic, OpenTTD sera mis en pause. Quand vous appuyez sur le bouton Continuer ou sur le bouton de pause normal, votre IA continuera à fonctionner. Si vous voulez désactiver temporairement la correspondance sans vider la zone de texte, vous pouvez utiliser la petite case à cocher à gauche de la zone d'édition.

Pour activer cette fonctionnalité, vous devez avoir le paramètre "gui.ai_developer_tools" activé. Pour le faire, vous pouvez ouvrir la console du jeu et entrer "set gui.ai_developer_tools 1".

[[File:en/Development/Script/AIDebug break on.png|frame|none|Fenêtre de débogage de l'IA - arrêt sur chaîne]]

==== Utilisation de la console pour le développeur ====

La console peut être accédée par la touche ` (près de "1") du clavier, et elle apparaît en haut de l'écran. On peut la faire défiler avec Shift + Page Up/Down.

Pour avoir une fenêtre séparée (seulement sous Windows), utilisez le paramètre <code>-d</code> tout seul (utilisez <code>-d ai=5</code> pour avoir seulement l'information sur l'IA) avec un raccourci:

 ./openttd -d

Cela produit cet affichage (uniquement sur Windows):

[[File:en/Development/Script/Openttd -d.png|frame|none|Exemple de Zuu de la console de développement version -d affichant les erreurs de l'IA]]

Pour Linux, utiliser <code>-d ai=5</code> enverra toutes les informations sur stdout.

==== Tracer ====

Les commandes <code>AILog.XXX()</code> peuvent être affichées directement dans la console du développeur par:

 ./openttd -d ai=5
 openttd.exe -d ai=5

ou en entrant <code>debug_level ai=5</code> dans la console.

== B.a.ba de l'IA ==

=== GetTick() ===

Quand votre <code>Start()</code> est appelé pour la première fois, <code>GetTick()</code> renvoie toujours 1. Sa seule utilité est de donner une indication du temps, car nous trouvons toujours utile de savoir quand une IA émet un message (était-ce il y a des lustres, ou tout récemment?). Ceci dit, vous voulez bien sûr savoir quand sa valeur est modifiée par le jeu.

Bien entendu, elle change quand vous appelez <code>Sleep()</code>, avec de la valeur exacte que vous avez spécifié dans <code>Sleep()</code>. Mais elle change aussi quand vous exécutez une commande. Cela est lié au fait qu'en réseau, cela prend du temps de faire quelque chose, et comme vous voulez savoir si quelque chose a vraiment été construit, vous devez attendre d'avoir un signal de retour du serveur. Maintenant, pour vous simplifier la vie, nous avons rendu identiques les version mono-joueur et multijoueurs: les deux attendent. En mono-joueur, c'est toujours de 1 tic, sauf si vous l'avez configuré avec <code>SetDelay()</code>. En multijoueurs, c'est au moins de 1 tic, mais cela dépend de la configuration du serveur. Si vous avez mis <code>SetDelay()</code> inférieur à sa valeur dans la configuration du serveur, c'est cette dernière qui gagnera, sinon ce sera <code>SetDelay()</code>.

Qu'est-ce que cela veut donc dire?

 GetTick() -> 3
 SetCompanyName()
 GetTick() -> 4 (ou plus)

Comme vous l'aurez remarqué, vous ne pouvez pas utiliser <code>GetTick()</code> pour autre chose que du débogage. Ce n'est pas un bon indicateur de temps, et il n'est pas utilisable pour faire quelque chose tous les 10 tics environ; pas du tout. Vous devrez faire un tel système par vous-mêmes.

=== Opcodes ===

Remember back in the [[en/Development/Script/Introduction#your-first-ai|Introduction]] when we told you that the AI would be suspended after X opcodes? Well, that was an half-truth. To dwell a little in the details, an opcode is, basically, one squirrel instruction. The framework simply count the number of squirrel instructions your AI does and put it to sleep after a certain amount. What's insidious about this is that it is possible to call C++ code from within squirrel, which instructions aren't counted because, well, it's not squirrel. 

For example, if I were to play on a 2048x2048 map and make use of a Valuator to valuate all tiles on the map using a valuator written in C++, I would steal all the CPU resources and "freeze" the game for some time. (Thanks to [http://www.tt-forums.net/viewtopic.php?p=892576#p892576 Morloth] for the explanation and example!)

== Game Mechanics ==

=== Map Coordinates ===

[[File:en/Development/Script/Ai-placed-coordinate-of-airport.png|frame|right|The AI placed this airport, using the top right most coordinate, which is also it's returned location. The airport size is X=4, Y=3]]

Map (X, Y) coordinates are done from the top to the bottom - the top-most coordinate is (0,0), the bottom-most coordinate is (Max_X-1, Max_Y-1). X is increased by going SW, and Y increased by going SE. Any time a more than one tile dimension object is returned, it'll be the most top coordinate, tending towards the top right.

However, an AI cannot access all coordinates as tiles. The outside edge of the map is reserved as non-buildable tiles. These are tiles in which the X or Y value is either 0, Max_X-1 (if X), or Max_Y-1 (if Y). The API will treat tiles with these coordinates as invalid.

This behavior varies, however, if the freeform_edges option is enabled. If freeform_edges is turned off, then the upper two edges (those where X or Y is 0) become accessible.

So with freeform_edges on, the top-most tile the AI can use is (1, 1). But with freeform_edges off, the top-most tile is (0, 0).

The bottom-most tile accessible to the AI is always (Max_X-2, Max_Y-2).

To get Max_X and Max_Y, the <code>AIMap.GetMapSizeX()</code> and <code>AIMap.GetMapSizeY()</code> functions can be used, respectively.

When using <code>AITile.IsBuildableRectangle</code> with [[en/Development/Script/Lists|Lists]], the list will contain those tiles where you can build an object of the size specified, where the returned tile is the one with the lowest X and Y value of the rectangle (or rather: the tile most North).

=== Distance Calculations ===

All in-game distances use [http://en.wikipedia.org/wiki/Taxicab_geometry Manhattan distance] calculations, so the distance between (3,3) and (5,5) calculated by the game is 4:
 abs(3-5)  + abs(3-5) = 4
Use <code>AITile.GetDistanceManhattanToTile</code> to get this distance between tiles. <code>AITile.GetDistanceSquareToTile</code> is much less necessary, calculating the same distance as 8:
 (3-5)^2 + (3-5)^2 = 8

The distance might not be exactly what a "plane would fly", since planes, boats and trains with the correct tracks can move diagonally, lowering the direct distance taken between tiles. Buses always must move Manhattan distances however due to having no type of diagonal roads. For an AI, you'll nearly always want to use <code>AITile.GetDistanceManhattanToTile</code>, as that is the function OpenTTD uses internally for distance calculations.

==== Tile Arithmetic ====

As part of various applications (e.g. pathfinding), an AI will need the ability to move around the map. Because of the way tile indices are represented, you can perform simple arithmetic on a tile index to find a new tile relative to its position. Adding or subtracting the result of <code>AIMap.GetTileIndex(x, y)</code> to a tile will yield the index of the tile ''x'' and ''y'' tiles from the original position.

For instance, the following code snippet will create a list of tiles directly adjacent to ''tile''...

 local adjacent = AITileList();
 adjacent.AddTile(tile - AIMap.GetTileIndex(1,0));
 adjacent.AddTile(tile - AIMap.GetTileIndex(0,1));
 adjacent.AddTile(tile - AIMap.GetTileIndex(-1,0));
 adjacent.AddTile(tile - AIMap.GetTileIndex(0,-1));

This snippet creates a list containing all tiles within an 11x11 square area centered around ''tile''...

 local area = AITileList();
 area.AddRectangle(tile - AIMap.GetTileIndex(5, 5), tile + AIMap.GetTileIndex(5, 5));

Because the Tile object in C++ is just an Integer, it's possible to wrap around the borders of the map using this trick. To avoid wrapping around the edge of the map, you should check the distance to the the new tile and makes sure it's within the distance you expect.

=== Cargos ===

CargoID, like any ID, is an index. An index on its own means nothing, it is just a pointer to a value in an array, and in this case, a cargo-array. The main problem with Cargo, is that you can't trust a value to mean something in all cases. NewGRFs are very powerful, and allow changing of cargos in all kinds of way. Normally, CargoID 0 represents Passengers, but with a single NewGRF, this can be changed to, say, Coal. Now here is the tricky part of it all: no longer you can transport this cargo from and to towns. So, how to make sure your AI is compatible enough that it works in all cases?

Well, say you want to transport stuff from one town to the other town. Than you most likely don't care if it is passengers or mail, just the one which is giving you the most profit, right? Well, that is mail in this case, but how to find out?

First, make a cargo list:

 local list = AICargoList();
 
Now filter what we want.. we want non-freight (short: mail, passengers, ... everything that doesn't go or goes to industry).

 list.Valuate(AICargo.IsFreight);
 list.KeepValue(0);

Next, we want the one that is most profitable for a given length (10 tiles in 2 days is what we use here, but use what ever value you want):

 list.Valuate(AICargo.GetCargoIncome, 10, 2);

Now the best cargo to transport is the first entry of the list:

 local cargo = list.Begin();

When using this method, you can get other types of cargo when loading certain NewGRFs. Nevertheless, there is always a cargo you can transport from and to towns, and there is always one that is most profitable. So it is not important if it is passengers or not. It doesn't matter what your AI transports as long as it makes profit (>=20k USD).


Of course it is also possible to find a cargo based on the class of the cargo. Don't just use value '0' for passengers, it might not hold for all NewGRFs. What is safe to do, is find the cargo that belongs to <code>AICargo.CC_PASSENGERS</code>. To give a simple code snippet which illustrates this:

 local list = AICargoList();
 local pass_cargo = -1;
 for (local cargo = list.Begin(); !list.IsEnd(); cargo = list.Next()) {
   if (AICargo.HasCargoClass(cargo, AICargo.CC_PASSENGERS)) {
     pass_cargo = cargo;
     break;
   }
 }
 if (pass_cargo == -1) AILog.Error("Your game doesn't have any passengers cargo, and as we are a passenger only AI, we can't do anything");

An alternative way:

 local cargoList = AICargoList();
 cargoList.Valuate(AICargo.HasCargoClass, AICargo.CC_PASSENGERS);
 cargoList.KeepValue(1);
 if (cargoList.Count() == 0) AILog.Error("Your game doesn't have any passengers cargo, and as we are a passenger only AI, we can't do anything");
 local paxCargo = cargoList.Begin();

At the end, either it gave an error, or pass_cargo is the value of the first cargo belonging to the <code>CC_PASSENGERS</code> class. More complex solutions are possible by using the Valuator and find that cargo belonging to the <code>CC_PASSENGERS</code> class that gives the most profit. Of course, without any NewGRFs this is always Passengers.

==== Bus station or Truck station ====

There is one simple way to find out if the cargo you want to transport should go to a bus station or a truck station. And it is the most obvious: if the cargo belongs to the <code>CC_PASSENGERS</code> class, it needs a bus station. All other cases need a truck station. So:

 local truck_station = !AICargo.HasCargoClass(cargo, AICargo.CC_PASSENGERS);

=== Towns ===

If a town seed tile hasn't been destroyed (a ''very'' rare occurrence) the tile returned by <code>AITown.GetLocation()</code> is '''always''' a road tile. Note that not all road tiles in a town are guaranteed to be connected to the seed tile.