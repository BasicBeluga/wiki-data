[[Translation:en/Archive/Source/Strings]]
 
<!--{{DevDoc}}-->{{pl/Development/Rozwój}}

<!--{{note|This page deals with [[Wikipedia:Internationalization_and_localization|i18n]] strings from a ''developers'' point of view. If you are interested in aspects on translations, see [[Format of langfiles]] for a more in-depth article. That article also covers language specific concepts like inflection due to gender, causes and plurality.}}-->
{{pl/Informacja|Ta strona dotyczy [https://www.wikipedia.org/wiki/Internationalization_and_localization i18n] ciągi z ''developers'' punkt widzenia. Jeśli interesują Cię aspekty tłumaczeń, zobacz [[pl/Archive/Source/Format plików lang|Format plików lang]] po bardziej szczegółowy artykuł. Artykuł ten obejmuje również pojęcia specyficzne dla języka, takie jak odmiana z powodu płci, przyczyn i mnogości.}}

OpenTTD ma wbudowaną obsługę napisów w wielu językach. Te widoczne dla użytkownika teksty muszą być przetłumaczone na wiele języków obcych.   Łańcuchy znaków zależne od języka są przechowywane w plikach tekstowych pod '''src/lang/''' i mają wzór <code>''[language name]''.txt</code>. Jak każdy plik kodu źródłowego są pod kontrolą wersji przez SVN. Językiem głównym jest angielski (British English) i zapisany jest w pliku '''english.txt''' . Aby uzyskać szczegółowe wyjaśnienie tych plików, patrz [[pl/Archive/Source/Format plików lang|Format plików lang]] . Podczas procesu kompilacji narzędzie „strgen” kompiluje pliki językowe w odpowiadające im pliki <code>.lng</code> pliki, które z kolei są wykorzystywane podczas gry. 


==Dodawanie ciągów==
Dodajesz ciąg, podając mu identyfikator, a następnie pewną liczbę spacji, następnie dwukropek ":" , a następnie sam ciąg. Użyj do tego pliku '''english.txt''' . Zgodnie z konwencją identyfikatory ciągów zawsze zaczynają się od ''STR_'' . Linia może polubić coś takiego:
<pre>STR_01A1_IS_GETTING_VERY_OLD   :{WHITE}{STRING} {COMMA} is getting very old</pre>
Zauważ, że lokalizacja, do której dodajesz ciąg, nie jest całkowicie dowolna (patrz [[#zakresy|Zakresy]] poniżej ) . Ciągi w nawiasach klamrowych ("{}") to ciągi znaków specjalnych interpretowane podczas ich renderowania. Jak można się domyślić, <code>{WHITE}</code> nadaje ciągowi biały kolor. Aby zapoznać się z listą specjalnych ciągów znaków, patrz <!--[[OpenTTDDevBlackBook/Special_strings|Special Strings]]-->[[pl/Archive/Source/OpenTTDDevBlackBook/Special strings|Ciągi Specjalne]] .<br />

==Komentarze==
Każda linia rozpoczynająca się od znaku skrótu "#" jest uważana za linię komentarza.
Puste linie (linia z tylko znakiem powrotu karetki) są ignorowane i mogą być używane do grupowania ciągów, które należą do siebie semantycznie.

==Specjalne ciągi znaków==
Ciągi mogą zawierać "Ciągi specjalne", które pozwalają modyfikować sposób renderowania ciągu lub zastępować symbole zastępcze. Lista ciągów specjalnych znajduje się w  <!--[[OpenTTDDevBlackBook/Special_strings|separate article]]-->[[pl/Archive/Source/OpenTTDDevBlackBook/Special strings|osobny artykuł]] .

==Zakresy==
<span id="ranges"></span>
Zakresy powinny być wizualnie oznaczone jako blok zarówno przez początkowe, jak i końcowe komentarze w ten sposób:
<pre>
############ zakres dla startów miesięcy
STR_MONTH_ABBREV_JAN                                            :Jan
STR_MONTH_ABBREV_FEB                                            :Feb
STR_MONTH_ABBREV_MAR                                            :Mar
# ...
############ zakres dla końców miesięcy
</pre>
<!--{{warning|'''Do not break ranges''' when adding strings as this might have unwanted side-effects!}}-->
{{pl/Uwaga|'''Nie przerywaj zakresów''' podczas dodawania ciągów, ponieważ może to mieć niepożądane skutki uboczne!}}
Zakresy są często używane do definiowania grupy tekstów, które ''nie'' są bezpośrednio przywoływane w kodzie źródłowym. Zamiast tego wykonywane jest obliczenie przesunięcia w stosunku do pierwszego wpisu bloku. W związku z tym do tekstów odwołuje się tylko pośrednio i w czasie wykonywania.

==Wewnętrzne '''(Internals)'''==
Technicznie identyfikatory ciągów są automatycznie przypisywane do liczb całkowitych. Odbywa się to podczas procesu kompilacji. Spójne odwołanie jest zapewnione przez plik nagłówkowy (patrz '''lang/table/strings.h''' ), który jest generowany automatycznie. Odpowiednim typem danych używanym dla łańcuchów w kodzie źródłowym C ++ jest <code>StringID</code> . Takie podejście pozwala wykonywać arytmetykę na StringID, na przykład obliczanie przesunięcia. 

==Funkcje przetwarzania zmiennych==
===Przykład===
Jak widzieliście wcześniej, musicie umieścić te specjalne modyfikatory w samym łańcuchu. Powróćmy do powyższego przykładu:
<pre>STR_01A1_IS_GETTING_VERY_OLD   :{WHITE}{STRING} {COMMA} is getting very old</pre>
Zarówno "STRING", jak i "COMMA" są zmiennymi. Konfigurujesz je, wywołując odpowiednią funkcję '''"SetDParam(uint n, uint32 v)"''' . Więc dla tego zrobiłbyś:
<pre>SetDParam(0, _vehicle_type_names[v->type - 0x10]);
SetDParam(1, v->unitnumber);</pre>
Dopiero potem wywołujesz odpowiednią funkcję losowania, na przykład:
<pre>DrawStringRightAligned(x, y, STR_01A1_IS_GETTING_VERY_OLD, colour);</pre>
Oba parametry "STR_01.." zostały skonfigurowane, a informacje ładnie wyświetlisz na ekranie.

===Lista funkcji===
Oprócz '''SetDParam(uint n, uint32 v)''' dostępne są inne funkcje '''SetDParam''xxx'' ''' :
{| class="wikitable"
|-
! Signatura 
! Opis
! Przykład
! Uwagi
|-
| <code>SetDParam(uint n, uint32 v)</code>
| Set the variable value at index ''n'' to value ''v''. 
| see above
| Depending on the variable used, the value is interpreted differently.
|-
| <span id="using_raw_string"><code>SetDParamStr(uint n, const char *str)</code></span>
| Use the verbatim string ''str'' to apply it to the variable at index ''n''. 
| Assume that it is <code>STR_XYZ: Hello World - {RAW_STRING}</code> in ''english.txt'' and <code>STR_XYZ: Hallo Welt - {RAW_STRING}</code> in ''german.txt''. The coding <pre>char *hello = 'Hello World!';
SetDParamStr(0, hello);
DrawStringRightAligned(x, y, STR_XYZ, colour);
</pre> would produce <code>Hello World - Hello World!</code> in English and <code>Hallo Welt - Hello World!</code> in German.
| Note that ''str'' is being used in a verbatim manner, i.e. the variable value is printed "as is" without any translation lookup in between (typically used for providing non-translated names to variables). Only use <code>{RAW_STRING}</code> as variable!
|-
| <code>SetDParamMaxDigits(uint n, uint count)</code>
| '''available since {{en/Revision|24801}}''': Emulate the variable value at index ''n'', which is of an integer type, by creating a number which has ''count'' maximal-width digits.
| Assume that for the current font, the digit ''8'' is the digit with the largest font width. If you call <code>SetDParamMaxDigits(1, 4)</code>, this would be equivalent to calling <code>SetDParam(1, 8888)</code>.
| rowspan="2" | These functions are typically used when there is a need to guess the maximal width of a certain string, such as in '''UpdateWidgetSize'''. Make use of this function, if you know an upper boundary of your variable and calculating the exact value may be expensive, but you just need a "good guess" for the total width of your final string.
|-
| <code>SetDParamMaxValue(uint n, uint64 max_value, uint min_count = 0)</code>
| '''available since {{en/Revision|24801}}''': Emulate the variable value at index ''n'', which is of an integer type, by creating a number with as many maximal-width digits as ''max_value'' provides. If ''min_count'' is provided, ensure that at least ''min_count'' digits are created.
| Assume that for the current font, the digit ''8'' is the digit with the largest font width. If you call <code>SetDParamMaxValue(1, 1234)</code>, this would be equivalent to calling <code>SetDParam(1, 8888)</code>, because ''1234'' consists of four digits. If you call <code>SetDParamMaxValue(2, 123, 5)</code>, this would be equivalent to calling <code>SetDParam(2, 88888)</code>, because ''123'' has only three digits, but you requested to have five digits at minimum.
|}

===Rozdzielczość zagnieżdżona za pomocą poleceń {STRINGx}===
<span id="nested_resolution"></span>
Za pomocą poleceń <code>{STRINGx}</code> można uruchomić zagnieżdżoną rozdzielczość ciągów. Podczas korzystania z funkcji do przetwarzania zmiennych indeksy odwołują się w ''kolejności od góry do dołu'' , podczas gdy węzły liści muszą znajdować się w ''kolejności od lewej do prawej'' .
Oto przykład: Niech ciągi zostaną zdefiniowane jako
<pre>
STR_A              : A
STR_X              : X
STR_Y              : Y
STR_TOP            : {STRING5}
STR_1ST_LEVEL      : {STRING1} / {STRING2}
STR_2ND_LEVEL_A    : {STRING}
STR_2ND_LEVEL_X    : {STRING} - {STRING} 
</pre>
Aby uzyskać wynik <code>A / X - Y</code> podczas rysowania ciągu <code>STR_TOP</code> , musisz ustawić zmienne w ten sposób:
<pre>
SetDParam(0, STR_1ST_LEVEL);
SetDParam(1, STR_2ND_LEVEL_A);
SetDParam(2, STR_A);
SetDParam(3, STR_2ND_LEVEL_X);
SetDParam(4, STR_X);
SetDParam(5, STR_Y);
DrawString(x, y, STR_TOP, colour);
</pre>
Ponadto zwróć uwagę, jak <code>STR_TOP</code> jest zdefiniowane jako <code>{STRING5}</code> : pierwsza zmienna <code>STR_1ST_LEVEL</code> wymaga miejsca na dwie zmienne (StringID ciągu na pokaż plus wartość jednej zmiennej). Druga zmienna <code>STR_1ST_LEVEL</code> wymaga miejsca na trzy zmienne (StringID ciągu do wyświetlenia plus dwie dodatkowe wartości zmiennych).

==Cykl życia==
"Źródło prawdy" dla ciągów i18n znajduje się tylko w tabelach tekstowych plików językowych (to jest na przykład "'''english.txt'''" ) . Oznacza to, że [http://translator.openttd.org/en/ WebTranslator]  jest aktualizowany automatycznie na podstawie najnowszego stanu dostępnego w ''bagażniku'' (''trunk'') repozytorium SVN. Dlatego można bezpiecznie usunąć cały wpis z "english.txt" , jeśli wiesz, że nie jest już używany w innym miejscu (Uwaga: jeśli nie znajdziesz nazwy łańcucha w żadnym pliku kodu źródłowego, nie możesz zakończyć że nie jest już używany z powodu [[#zakresy|zasięgu]]]). Upewnij się, że wyczyściłeś również wpis we wszystkich innych językach, ponieważ nie dzieje się to automatycznie w ''bagażniku'' (''trunk'').

Co więcej, mówiąc bardziej ogólnie, jeśli chcesz ''zmienić'' oryginalny tekst angielski, musisz pomyśleć o wpływie również na inne języki. Oto kilka praktycznych zasad:
* Jeśli masz pewność, że twoje zmiany wpłyną na wszystkie języki (także te, których nie znasz) w ten sam sposób (na przykład, chcesz zmienić '''{RED}''' na '''{GREEN}''' ), a następnie sam zmień go mechanicznie we wszystkich językach. Nie czekaj, aż tłumacz dostosuje wszystkie inne języki.
* Jeśli nie możesz ocenić, czy zmiana zmieni rzeczy w innych językach (na przykład zmieniłeś jedno słowo w zdaniu) lub jeśli wiesz, że to na pewno zmieni (na przykład zmieniłeś całą frazę), to wykonaj modyfikacja w języku angielskim i usunięcie wszystkich innych tłumaczeń tego ciągu z innych tabel tekstowych. Dla tłumaczy dużo łatwiej jest znaleźć brakujące tłumaczenie niż szukać zmienionego! Ponieważ SVN przechowuje historię, oryginalne tłumaczenie również nie jest tracone i może zostać przywrócone, jeśli jest to naprawdę konieczne.<br /> Także w bieżącym przypadku, jeśli jesteś pewien określonego języka (na przykład jest to język ojczysty) jak należy dostosować tłumaczenie, dostosuj je sam. Wciąż pozbywaj się innych ciągów w innych językach, których nie znasz wystarczająco dobrze. W razie wątpliwości, czy to, co robisz, jest prawidłowe, nie zmieniaj wpisu, ale go usuń.


<!--[[Category:Development]]--> [[Category:pl/Rozwój]]